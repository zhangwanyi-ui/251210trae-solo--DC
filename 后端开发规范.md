# DC在线业务系统 - 后端开发规范

## 1. 文档概述

### 1.1 文档目的

本文档详细描述了DC在线业务系统的后端开发规范，包括技术栈、项目结构、命名规范、代码风格、API设计、数据库操作、中间件、错误处理、日志管理、安全性等，为后端开发团队提供明确的开发依据，确保后端代码质量高、风格统一、易于维护和扩展。

### 1.2 适用范围

本规范适用于DC在线业务系统的后端开发团队，包括新功能开发、代码维护、性能优化等所有后端相关工作。

## 2. 技术栈

| 技术 | 版本 | 用途 |
|------|------|------|
| Node.js | 18+ | 运行环境 |
| Express | 4.18+ | Web框架 |
| MySQL | 8.0+ | 关系型数据库 |
| Sequelize | 6.35+ | ORM框架 |
| JWT | 9.0+ | 身份认证 |
| Redis | 6.0+ | 缓存数据库 |
| Axios | 1.6+ | HTTP客户端 |
| Morgan | 1.10+ | 日志中间件 |
| Helmet | 7.1+ | 安全中间件 |
| CORS | 2.8+ | 跨域资源共享 |
| Jest | 29+ | 单元测试 |
| Supertest | 6.3+ | API测试 |
| PM2 | 5.3+ | 进程管理 |
| Docker | 24+ | 容器化部署 |

## 3. 项目结构

### 3.1 目录结构

```
├── src/                     # 源代码目录
│   ├── config/             # 配置文件
│   │   ├── config.js       # 主配置文件
│   │   ├── db.js           # 数据库配置
│   │   └── redis.js        # Redis配置
│   ├── controllers/        # 控制器层
│   │   ├── authController.js   # 认证控制器
│   │   ├── userController.js   # 用户控制器
│   │   ├── roleController.js   # 角色控制器
│   │   └── permissionController.js # 权限控制器
│   ├── middlewares/        # 中间件
│   │   ├── authMiddleware.js   # 认证中间件
│   │   ├── errorMiddleware.js  # 错误处理中间件
│   │   ├── loggerMiddleware.js # 日志中间件
│   │   └── validationMiddleware.js # 验证中间件
│   ├── models/             # 数据模型
│   │   ├── User.js         # 用户模型
│   │   ├── Role.js         # 角色模型
│   │   ├── Permission.js   # 权限模型
│   │   └── index.js        # 模型索引
│   ├── routes/             # 路由配置
│   │   ├── authRoutes.js   # 认证路由
│   │   ├── userRoutes.js   # 用户路由
│   │   ├── roleRoutes.js   # 角色路由
│   │   └── index.js        # 路由索引
│   ├── services/           # 业务逻辑层
│   │   ├── authService.js  # 认证服务
│   │   ├── userService.js  # 用户服务
│   │   └── roleService.js  # 角色服务
│   ├── utils/             # 工具函数
│   │   ├── auth.js         # 认证工具
│   │   ├── logger.js       # 日志工具
│   │   ├── validator.js    # 验证工具
│   │   └── response.js     # 响应工具
│   ├── app.js             # 应用入口
│   └── server.js           # 服务器启动
├── tests/                  # 测试文件
│   ├── unit/              # 单元测试
│   └── integration/       # 集成测试
├── .env.example           # 环境变量示例
├── .env                   # 环境变量配置（不提交到Git）
├── .eslintrc.js           # ESLint配置
├── .prettierrc.json       # Prettier配置
├── jest.config.js         # Jest配置
├── package.json           # 项目配置和依赖
├── README.md              # 项目说明文档
└── Dockerfile             # Docker配置
```

### 3.2 文件组织原则

- **分层架构**：控制器层、服务层、模型层分离
- **模块化**：按功能模块组织代码
- **单一职责**：每个文件只负责一个功能
- **高内聚低耦合**：相关功能放在一起，减少模块间依赖
- **易于扩展**：预留扩展空间，便于后续功能迭代

## 4. 命名规范

### 4.1 文件命名

- **控制器文件**：camelCase + Controller.js，如 `userController.js`
- **服务文件**：camelCase + Service.js，如 `userService.js`
- **模型文件**：PascalCase + .js，如 `User.js`
- **路由文件**：camelCase + Routes.js，如 `userRoutes.js`
- **中间件文件**：camelCase + Middleware.js，如 `authMiddleware.js`

### 4.2 变量命名

- **普通变量**：camelCase，如 `userInfo`、`isAuthenticated`
- **常量**：UPPER_SNAKE_CASE，如 `JWT_SECRET`、`DB_HOST`
- **数组**：复数形式，如 `users`、`roles`
- **布尔值**：is/has/should前缀，如 `isAdmin`、`hasPermission`

### 4.3 函数命名

- **普通函数**：camelCase，如 `getUserById`、`createUser`
- **异步函数**：async前缀或使用async/await，如 `async getUserByEmail`
- **控制器函数**：camelCase，如 `getUsers`、`updateUser`
- **服务函数**：camelCase，如 `findUserById`、`saveUser`

### 4.4 数据库命名

- **表名**：复数形式，蛇形命名法，如 `sys_users`、`sys_roles`
- **字段名**：蛇形命名法，如 `user_id`、`role_name`
- **索引名**：idx_表名_字段名，如 `idx_sys_users_username`
- **外键名**：fk_表名_关联表名，如 `fk_sys_users_role_id`

## 5. 代码风格

### 5.1 缩进和换行

- **缩进**：使用2个空格进行缩进
- **换行**：单行代码长度不超过120个字符
- **空行**：在函数、类、逻辑块之间添加适当空行
- **大括号**：使用K&R风格，左大括号不换行

### 5.2 引号和分号

- **字符串**：使用单引号 `'`
- **对象属性**：当属性名是关键字或包含特殊字符时使用引号
- **分号**：必须使用分号

### 5.3 代码示例

```javascript
// 控制器示例
const express = require('express');
const router = express.Router();
const userService = require('../services/userService');
const authMiddleware = require('../middlewares/authMiddleware');
const { validateUser } = require('../utils/validator');

// 获取用户列表
router.get('/', authMiddleware, async (req, res, next) => {
  try {
    const users = await userService.getUsers(req.query);
    res.status(200).json({
      code: 200,
      message: 'success',
      data: users
    });
  } catch (error) {
    next(error);
  }
});

// 创建用户
router.post('/', authMiddleware, validateUser, async (req, res, next) => {
  try {
    const user = await userService.createUser(req.body);
    res.status(201).json({
      code: 201,
      message: 'User created successfully',
      data: user
    });
  } catch (error) {
    next(error);
  }
});

module.exports = router;
```

## 6. API设计规范

### 6.1 RESTful API设计

- **URL格式**：`http://api.example.com/api/v1/[resource]/[id]`
- **HTTP方法**：
  - GET：获取资源
  - POST：创建资源
  - PUT：更新资源
  - DELETE：删除资源
  - PATCH：部分更新资源

### 6.2 资源命名

- **资源名**：复数形式，如 `/users`、`/roles`
- **嵌套资源**：使用斜杠分隔，如 `/users/:userId/roles`
- **版本控制**：使用URL前缀，如 `/api/v1/users`

### 6.3 请求/响应格式

#### 6.3.1 请求格式

- **查询参数**：用于过滤、排序、分页，如 `?page=1&pageSize=10&keyword=test`
- **请求体**：JSON格式，用于创建或更新资源
- **请求头**：
  - `Content-Type: application/json`
  - `Authorization: Bearer [token]`

#### 6.3.2 响应格式

- **成功响应**：
  ```json
  {
    "code": 200,
    "message": "success",
    "data": {
      "list": [],
      "total": 100,
      "page": 1,
      "pageSize": 10
    }
  }
  ```

- **失败响应**：
  ```json
  {
    "code": 400,
    "message": "Invalid parameters",
    "data": null
  }
  ```

### 6.4 状态码

| 状态码 | 含义 |
|--------|------|
| 200 | 请求成功 |
| 201 | 资源创建成功 |
| 400 | 请求参数错误 |
| 401 | 未授权，需要登录 |
| 403 | 拒绝访问，没有权限 |
| 404 | 资源不存在 |
| 500 | 服务器内部错误 |

## 7. 数据库操作规范

### 7.1 Sequelize使用规范

- **模型定义**：使用Sequelize的Model API定义模型
- **关联关系**：明确定义模型之间的关联关系（一对一、一对多、多对多）
- **查询优化**：
  - 使用 `attributes` 限制返回字段
  - 使用 `include` 合理加载关联数据
  - 使用 `limit` 和 `offset` 进行分页
  - 避免N+1查询问题

### 7.2 事务管理

- **使用事务**：对于涉及多个数据库操作的业务逻辑，使用事务保证数据一致性
- **事务隔离级别**：根据业务需求选择合适的隔离级别
- **错误处理**：在事务中捕获错误并回滚

### 7.3 模型示例

```javascript
// User.js - 用户模型
const { DataTypes } = require('sequelize');
const sequelize = require('../config/db');
const Role = require('./Role');

const User = sequelize.define('User', {
  userId: {
    type: DataTypes.BIGINT,
    primaryKey: true,
    autoIncrement: true,
    field: 'user_id'
  },
  username: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true,
    validate: {
      notEmpty: true
    }
  },
  password: {
    type: DataTypes.STRING(255),
    allowNull: false,
    validate: {
      notEmpty: true
    }
  },
  realName: {
    type: DataTypes.STRING(50),
    allowNull: false,
    field: 'real_name'
  },
  email: {
    type: DataTypes.STRING(100),
    unique: true,
    validate: {
      isEmail: true
    }
  },
  phone: {
    type: DataTypes.STRING(20),
    unique: true
  },
  roleId: {
    type: DataTypes.BIGINT,
    field: 'role_id',
    references: {
      model: Role,
      key: 'role_id'
    }
  },
  status: {
    type: DataTypes.TINYINT,
    defaultValue: 1,
    comment: '0:禁用, 1:启用'
  },
  lastLoginTime: {
    type: DataTypes.DATE,
    field: 'last_login_time'
  },
  lastLoginIp: {
    type: DataTypes.STRING(50),
    field: 'last_login_ip'
  },
  createdAt: {
    type: DataTypes.DATE,
    field: 'created_at',
    defaultValue: DataTypes.NOW
  },
  updatedAt: {
    type: DataTypes.DATE,
    field: 'updated_at',
    defaultValue: DataTypes.NOW,
    onUpdate: DataTypes.NOW
  },
  createdBy: {
    type: DataTypes.BIGINT,
    field: 'created_by'
  },
  updatedBy: {
    type: DataTypes.BIGINT,
    field: 'updated_by'
  }
}, {
  tableName: 'sys_users',
  timestamps: true,
  underscored: true
});

// 关联关系
User.belongsTo(Role, { as: 'role', foreignKey: 'role_id' });

module.exports = User;
```

## 8. 中间件使用规范

### 8.1 中间件分类

- **应用级中间件**：全局使用，如日志、安全、跨域等
- **路由级中间件**：特定路由使用，如认证、权限控制等
- **错误处理中间件**：处理应用中的错误
- **内置中间件**：Express内置的中间件，如 `express.json()`
- **第三方中间件**：第三方库提供的中间件，如 Morgan、Helmet 等

### 8.2 中间件顺序

1. 日志中间件
2. 安全中间件（Helmet）
3. 跨域中间件（CORS）
4. 解析中间件（express.json(), express.urlencoded()）
5. 认证中间件
6. 权限中间件
7. 路由处理
8. 错误处理中间件

### 8.3 中间件示例

```javascript
// authMiddleware.js - 认证中间件
const jwt = require('jsonwebtoken');
const { JWT_SECRET } = require('../config/config');

const authMiddleware = (req, res, next) => {
  try {
    // 从请求头获取令牌
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        code: 401,
        message: 'Unauthorized: Missing or invalid token',
        data: null
      });
    }

    // 提取令牌
    const token = authHeader.split(' ')[1];
    
    // 验证令牌
    const decoded = jwt.verify(token, JWT_SECRET);
    
    // 将用户信息存储到请求对象中
    req.user = decoded;
    
    next();
  } catch (error) {
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({
        code: 401,
        message: 'Unauthorized: Invalid token',
        data: null
      });
    }
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        code: 401,
        message: 'Unauthorized: Token expired',
        data: null
      });
    }
    next(error);
  }
};

module.exports = authMiddleware;
```

## 9. 错误处理

### 9.1 错误类型

- **业务错误**：如参数错误、资源不存在等
- **系统错误**：如数据库连接失败、Redis连接失败等
- **认证错误**：如令牌无效、过期等
- **权限错误**：如没有访问权限等

### 9.2 错误处理机制

1. **使用try-catch**：捕获异步操作中的错误
2. **使用错误中间件**：统一处理应用中的所有错误
3. **自定义错误类**：创建自定义错误类，包含错误码、错误信息等
4. **错误日志**：记录详细的错误信息，便于调试和分析

### 9.3 错误中间件示例

```javascript
// errorMiddleware.js - 错误处理中间件
const errorMiddleware = (err, req, res, next) => {
  console.error('Error:', err);
  
  // 设置默认错误码和信息
  let statusCode = 500;
  let message = 'Internal Server Error';
  let code = 500;
  
  // 根据错误类型设置不同的状态码和信息
  if (err.name === 'ValidationError') {
    statusCode = 400;
    code = 400;
    message = 'Validation Error: ' + Object.values(err.errors).map(error => error.message).join(', ');
  } else if (err.name === 'SequelizeUniqueConstraintError') {
    statusCode = 400;
    code = 400;
    message = 'Unique Constraint Error: ' + err.errors[0].message;
  } else if (err.statusCode) {
    statusCode = err.statusCode;
    code = err.statusCode;
    message = err.message;
  }
  
  // 返回错误响应
  res.status(statusCode).json({
    code,
    message,
    data: null
  });
};

module.exports = errorMiddleware;
```

## 10. 日志管理

### 10.1 日志级别

- **DEBUG**：调试信息，开发环境使用
- **INFO**：普通信息，如请求日志、操作日志等
- **WARN**：警告信息，如配置错误、性能问题等
- **ERROR**：错误信息，如异常、崩溃等
- **FATAL**：致命错误，如系统崩溃、数据丢失等

### 10.2 日志记录

- **请求日志**：使用Morgan记录HTTP请求
- **业务日志**：使用自定义日志工具记录业务操作
- **错误日志**：记录应用中的错误信息
- **访问日志**：记录用户访问行为

### 10.3 日志工具示例

```javascript
// logger.js - 日志工具
const winston = require('winston');
const { LOG_LEVEL } = require('../config/config');

// 创建日志记录器
const logger = winston.createLogger({
  level: LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp({
      format: 'YYYY-MM-DD HH:mm:ss'
    }),
    winston.format.json()
  ),
  transports: [
    // 控制台输出
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    // 文件输出
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),
    new winston.transports.File({
      filename: 'logs/combined.log',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    })
  ]
});

module.exports = logger;
```

## 11. 安全性

### 11.1 认证与授权

- **使用JWT**：用于用户身份认证
- **密码加密**：使用bcrypt或argon2加密存储密码
- **权限控制**：基于角色的访问控制（RBAC）
- **最小权限原则**：只授予用户必要的权限

### 11.2 数据安全

- **输入验证**：验证所有用户输入，防止SQL注入、XSS等攻击
- **输出编码**：对输出数据进行编码，防止XSS攻击
- **敏感数据保护**：加密存储敏感数据，如密码、API密钥等
- **HTTPS**：使用HTTPS加密传输数据

### 11.3 防止常见攻击

- **SQL注入**：使用参数化查询或ORM框架
- **XSS攻击**：输入验证、输出编码
- **CSRF攻击**：使用CSRF令牌
- **DDoS攻击**：使用限流、缓存、CDN等
- **命令注入**：验证和过滤用户输入

### 11.4 安全中间件

```javascript
// app.js - 安全中间件配置
const express = require('express');
const helmet = require('helmet');
const cors = require('cors');
const morgan = require('morgan');

const app = express();

// 安全中间件
app.use(helmet());

// 跨域中间件
app.use(cors({
  origin: process.env.CORS_ORIGIN || '*',
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// 请求日志中间件
app.use(morgan('combined'));

// 解析中间件
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// ... 其他配置

module.exports = app;
```

## 12. 测试规范

### 12.1 测试类型

- **单元测试**：测试单个函数或模块
- **集成测试**：测试模块之间的交互
- **API测试**：测试API接口
- **端到端测试**：测试完整的业务流程

### 12.2 测试覆盖率

- **目标覆盖率**：≥80%
- **关键功能**：100%覆盖
- **工具**：Jest + Supertest

### 12.3 测试文件命名

- **测试文件位置**：tests/目录下
- **测试文件名**：[被测试文件].test.js，如 `userService.test.js`

### 12.4 测试示例

```javascript
// userService.test.js - 用户服务测试
const { expect } = require('chai');
const sinon = require('sinon');
const UserService = require('../src/services/userService');
const User = require('../src/models/User');

describe('UserService', () => {
  describe('getUserById', () => {
    it('should return a user when given a valid ID', async () => {
      // 模拟数据
      const mockUser = {
        userId: 1,
        username: 'testuser',
        realName: 'Test User'
      };
      
      // 模拟User.findByPk方法
      sinon.stub(User, 'findByPk').resolves(mockUser);
      
      // 调用服务方法
      const user = await UserService.getUserById(1);
      
      // 断言结果
      expect(user).to.be.an('object');
      expect(user.userId).to.equal(1);
      expect(user.username).to.equal('testuser');
      
      // 恢复原始方法
      User.findByPk.restore();
    });
    
    it('should return null when given an invalid ID', async () => {
      // 模拟User.findByPk方法返回null
      sinon.stub(User, 'findByPk').resolves(null);
      
      // 调用服务方法
      const user = await UserService.getUserById(999);
      
      // 断言结果
      expect(user).to.be.null;
      
      // 恢复原始方法
      User.findByPk.restore();
    });
  });
});
```

## 13. 性能优化

### 13.1 数据库优化

- **索引优化**：为经常查询的字段创建索引
- **查询优化**：避免使用SELECT *，只查询需要的字段
- **分页查询**：使用LIMIT和OFFSET进行分页
- **批量操作**：使用批量插入、更新等操作
- **连接池**：使用数据库连接池，减少连接开销

### 13.2 缓存优化

- **使用Redis缓存**：缓存热点数据，如用户信息、配置信息等
- **缓存策略**：合理设置缓存过期时间
- **缓存失效处理**：使用缓存穿透、缓存击穿、缓存雪崩等解决方案

### 13.3 代码优化

- **异步编程**：使用async/await处理异步操作
- **避免阻塞**：避免在主线程中执行耗时操作
- **代码拆分**：将代码拆分为模块化、可复用的组件
- **内存管理**：避免内存泄漏，及时释放资源

### 13.4 服务器优化

- **使用PM2**：进程管理，实现负载均衡
- **使用CDN**：静态资源加速
- **使用Gzip**：压缩响应数据
- **使用HTTP/2**：提高传输效率

## 14. 部署规范

### 14.1 环境配置

- **开发环境**：本地开发，使用.env.development配置
- **测试环境**：测试部署，使用.env.test配置
- **生产环境**：正式部署，使用.env.production配置

### 14.2 部署方式

- **PM2部署**：使用PM2管理Node.js进程
- **Docker部署**：使用Docker容器化部署
- **CI/CD**：使用CI/CD工具实现自动化部署

### 14.3 环境变量

- **敏感信息**：如数据库密码、API密钥等，使用环境变量配置
- **不提交到Git**：.env文件不提交到Git仓库，使用.env.example作为示例

### 14.4 Docker配置示例

```dockerfile
# Dockerfile
FROM node:18-alpine

# 设置工作目录
WORKDIR /app

# 复制package.json和package-lock.json
COPY package*.json ./

# 安装依赖
RUN npm install --production

# 复制源代码
COPY src/ ./src/
COPY .env.example ./.env

# 暴露端口
EXPOSE 3000

# 启动应用
CMD ["node", "src/server.js"]
```

## 15. 代码审查

### 15.1 审查标准

- **代码风格**：符合本规范
- **代码质量**：可读性高，易于维护
- **性能**：无明显性能问题
- **安全性**：无安全漏洞
- **测试覆盖率**：达到目标要求

### 15.2 审查流程

1. **提交代码**：开发者提交代码到Git仓库
2. **创建PR**：创建Pull Request
3. **代码审查**：其他开发者审查代码
4. **修改代码**：根据审查意见修改代码
5. **合并代码**：审查通过后合并代码

## 16. 版本控制

### 16.1 Git使用规范

- **分支管理**：使用Git Flow或GitHub Flow
- **提交信息**：清晰、简洁，使用英文
- **提交频率**：小步提交，频繁提交
- **代码冲突**：及时解决代码冲突
- **标签管理**：使用语义化版本号打标签

### 16.2 提交信息格式

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Type**：
- feat: 新功能
- fix: 修复bug
- docs: 文档更新
- style: 代码风格调整
- refactor: 代码重构
- test: 测试代码
- chore: 构建流程或辅助工具变动

**示例**：
```
feat(user): 添加用户查询功能

- 实现根据用户名查询用户
- 实现根据邮箱查询用户
- 添加分页支持
```

## 17. 附录

### 17.1 常用工具

- **VS Code**：推荐的代码编辑器
- **Postman**：API测试工具
- **Sequel Pro**：MySQL客户端
- **Redis Desktop Manager**：Redis客户端
- **PM2**：进程管理工具
- **Docker**：容器化工具

### 17.2 资源链接

- [Node.js官方文档](https://nodejs.org/)
- [Express官方文档](https://expressjs.com/)
- [Sequelize官方文档](https://sequelize.org/)
- [JWT官方文档](https://jwt.io/)
- [Redis官方文档](https://redis.io/)
- [Jest官方文档](https://jestjs.io/)
- [Docker官方文档](https://docs.docker.com/)

### 17.3 联系方式

| 角色 | 姓名 | 联系方式 |
|------|------|----------|
| 后端开发负责人 | XXX | XXX@example.com |
| 数据库管理员 | XXX | XXX@example.com |
| 产品经理 | XXX | XXX@example.com |